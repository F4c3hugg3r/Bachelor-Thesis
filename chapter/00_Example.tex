\section{Entwurf des eigenen Lösungskonzepts}
\begin{itemize}
\item Darstellung des eigenen Ansatzes, ggf. Abgrenzung von anderen Arbeiten
\item Vor-/Nachteile
\item \ldots
\end{itemize}

\section{Auswahl/Entwurf der Hardware}
\ldots
\section{Auswahl/Entwurf der Software}
\subsection{Entwurf von Lösungsmodulen}
\ldots


%%
%% Alt
%%

\begin{table}[htbp]
\caption{OSI-7-Schichtenmodell}
\resizebox{\textwidth}{!}{
\begin{tabular}{|c|c|c|c|c|}\hline
  \multicolumn{3}{|c|}{\textbf{Schicht}} & \textbf{Beispielprotokoll} & \textbf{TCP/IP-Modell} \\ \hline
  7 & Anwendungsschicht & Application Layer & \multirow{3}{*}{HTTP, FTP, SNMP} & \multirow{3}{*}{Application Layer} \\ \cline{1-3}
  6 & Darstellungsschicht & Presentation Layer & & \\ \cline{1-3}
  5 & Sitzungsschicht & Session Layer & & \\ \hline
  4 & Transportschicht & Transport Layer & TCP, UDP & Transport Layer \\ \hline
  3 & Vermittlungsschicht & Networking Layer & IPv4, IPv6, ICMP & Internet Layer \\ \hline
  2 & Sicherungsschicht & Data Link Layer & \multirow{2}{*}{Ethernet, WLAN, ISDN} & \multirow{2}{*}{Link Layer} \\ \cline{1-3}
  1 & Physikalische Schicht & Physical Layer & & \\ \hline
\end{tabular}
}
\label{tab:OSI-7-Schichtenmodell}
\end{table}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=12cm]{wireless_sensor_network}
	\caption{Aufbau eines drahtlosen Sensornetzwerkes}
	\label{fig:wsn}
\end{figure}

Bei drahtlosen Sensornetzen, international auch Wireless Sensor Networks (WSN) genannt, handelt es sich um Netzwerke aus kleinen Sensoren, die ihre Messergebnisse zu einer zentralen Station senden. Die Sensoren helfen dabei einander, die Informationen weiterzureichen (siehe Abbildung \ref{fig:wsn}). So ein drahtloses Sensornetz kann zum Beispiel in einem Gebäude Temperatur- und Luftfeuchtigkeitswerte an eine zentrale Station liefern, die dann die Klimaanlage entsprechend ansteuert. Eine komplette Verkabelung jedes einzelnen Sensors kann dabei je nach Anzahl sehr aufwendig und kostspielig sein. Wenn die Sensoren dazu noch mobil sein sollen, empfiehlt sich eine drahtlose Kommunikation.

Ein Sensor in einem drahtlosen Sensornetz ist ausgestattet mit einer Kommunikationseinheit, die sich selbstständig innerhalb des Netzes konfiguriert und darüber die eingelesenen Messgrößen zu einer zentralen Stelle transportiert.

%%Ein Sensor ist dabei ein typisches Smart Object. Es 
%% Das Steuergerät soll dabei möglichst klein sein, damit es in einem Steckdosengehäuse Platz finden kann. 
%% Der Fernzugriff soll mithilfe des Protokolls IPv6 erfolgen, um zukunftssicher auf die Infrastruktur des Internet verwenden zu können. 

\subsection{Smart Objects}\label{Smart Objects}

Diese Definition von Smart Objects \index{Smart Object} beruht auf \textcite{vasseur10interconnecting}. Dabei handelt es sich um kleine Objekte, die mit folgenden Einheiten ausgestattet sind:

\begin{itemize}
	\itemsep 0pt
	\item eine Form von Sensor und/oder Aktor
	\item ein kleiner Mikrocontroller
	\item eine Kommunikationseinheit
	\item eine Energieversorgung
\end{itemize}

Ein Sensor und/oder Aktor wird benötigt, um mit der Umwelt interagieren zu können. Ein Sensor kann bestimmte Messgrößen erfassen, die dann verarbeitet werden können. Ein Aktor ist das Gegenstück zu einem Sensor. Über ihn kann aktiv die Umwelt beeinflusst werden. Die Kommunikationseinheit befähigt das Smart Object über ein Netzwerk kommunizieren zu können. Es ist dabei möglich mit anderen Smart Objects zu kommunizieren als auch mit weit entfernten Geräten, im Falle des Internets weltweit. Ein kleiner Mikrocontroller übernimmt die Informationsverarbeitung. Dieser nimmt Daten von Sensoren entgegen bzw. steuert den Aktor. Die Kommunikation wird ebenso von ihm geregelt, von einem Sensor gemessene Werte können über das Netzwerk weitergegeben werden. Der Mikrocontroller kann als Kern des Smart Object angesehen werden. Die Energieversorgung ist notwendig, um alle Einheiten ausreichend mit elektrischer Energie zu versorgen.

Alle diese technischen Eigenschaften machen ein Objekt aber noch nicht zu einem Smart Object. Erst die Anwendung und sein Verhalten machen aus einem Objekt mit den obigen Eigenschaften ein Smart Object. Allerdings ist es sehr schwierig, dieses Verhalten zu definieren. Die Anwendungen sind sehr unterschiedlich und es ist völlig unbekannt, wie Smart Objects in der Zukunft eingesetzt werden. Gemeinsam ist allen Anwendungen allerdings, dass Smart Objects mit der physikalischen Umwelt interagieren und über ein Netzwerk kommunizieren. Dieses Verhalten und die obigen technischen Eigenschaften machen ein Smart Object aus.

Von der Kommunikationstechnologie her ähnelt ein Smart Object einem Sensor in einem Sensornetz. Allerdings ist im Gegensatz zu einem Sensornetz ein Netz aus Smart Objects nicht allein auf die Datenübermittlung fokussiert. Bei einem Sensornetz ist der Datenfluss immer vom Sensor ins Netzwerk, wohingegen der Datenfluss bei einem Smart Object bidirektional ist. Der Fokus liegt dabei auf eine Vielzahl von Funktionen insbesondere der Steuerung und Überwachung \citep[Seite 12]{vasseur10interconnecting}. Es ist also die Anwendung, die ein Gerät zu einem Smart Object macht. Aber Entwicklungen, hauptsächlich in der Energieversorgung und Kommunikationstechnik, kommen beiden Forschungsgebieten zugute.


\subsection{Internet-of-Things}

\begin{figure}[htbp]
	\centering
	\includegraphics{internet_of_things}
	\caption{Die Internet-of-Things Vision \cite[Figure 1.2]{Bormann:6LoWPAN}}
	\label{fig:internet_of_things}
\end{figure}

Das Internet-of-Things, auch Internet der Dinge genannt, ist eine Vision, wie sich das Internet in Zukunft entwickeln kann. Es soll aus der Vernetzung vieler Kleinstgeräte -- auch oder vielleicht hauptsächlich Smart Objects -- bestehen. \textcite{Bormann:6LoWPAN} betrachten das Internet-of-Things als eine weitere Schale des Internets (Abbildung \ref{fig:internet_of_things}), die gerade anfängt sich heraus zu bilden. Der Kern des Internets (Core Internet) besteht heute aus vielen Routern und Servern, die zusammen Millionen von Teilnehmern ausmachen. Um diesen Kern herum liegt das sogenannte Fringe Internet, was beispielsweise aus privaten Rechnern oder Laptops besteht, aber auch aus lokalen Netzwerken, die zum Internet verbunden werden. Die Teilnehmer des Fringe Internet gehen in die Milliarden. Um dieses Fringe Internet herum beginnt sich eine weitere Schale zu bilden, das sogenannte Internet-of-Things. Auf lange Sicht kann hier mit Billionen von Teilnehmern gerechnet werden. Hauptsächlich bestehen diese Teilnehmer aus IP-fähigen eingebetteten Systemen (embedded systems). Eine so große Zahl an Teilnehmern kann nur mithilfe des Internet Protokolls der Version 6 ans Internet angeschlossen werden, da das bisherige Internet Protokoll der Version 4 keine freien Adressräume mehr zur Verfügung hat.

\section{Theoretische Grundlagen}
\ldots

\section{Aufbau der Implementierung}





\section{Contiki-Verzeichnisstruktur}
%\section{Contiki Verzeichnisstruktur}

Die Contiki-Verzeichnisstruktur besteht aus verschiedenen Unterverzeichnissen, die verschiedene Bedeutungen haben.

\begin{lstlisting}[caption=Contiki-Verzeichnisstruktur mit ausgewählten Unterverzeichnissen]{Contiki Dateistruktur}
/apps                                     
    /ftp                                      
    /ping6                                
    /telnet                               
    /telnetd                              
    /twitter                              
    /webserver                            
    /webserver-nano                       
    ...                                   
/core                                    
    /lib                                  
    /net                                  
    /sys                                  
    ...
/cpu
    /arm
    /avr
    ...
/doc
/examples
    /webserver-ipv6-raven
    ...
/platform
    /avr-raven
    /avr-zigbit
    ...
/tools
\end{lstlisting}

Das Verzeichnis /core beinhaltet das Kernstück von Contiki. Hier wird zum Beispiel das System im Unterverzeichnis /sys definiert. Das beinhaltet das Prozesshandling und Protothreads sowie verschiedene Timer. Ebenfalls befindet sich hier im Unterverzeichnis /net der Netzwerk-Stack aufbauend auf uIP. Zum Netzwerk-Stack gehört auch IEEE 802.15.4 und 6LoWPAN. Im Unterverzeichnis /lib stehen verschiedene libraries zur Verfügung.

In den beiden Verzeichnissen /cpu und /platform ist die unterschiedliche Hardware beschrieben, die von Contiki unterstützt wird. Ein Programm, das auf einem Zigbit-Modul vom Hersteller Atmel geladen werden soll, verwendet die Verzeichnisse /platform/avr-zigbit und /cpu/avr.

Das Verzeichnis /examples beinhaltet Beispielprojekte. Hier gibt es ein Projekt webserver-ipv6-raven. Anhand dieses Beispiels wird deutlich, was notwendig ist, um eine Webserver-Applikation für das Ravenboard zu kompilieren.

Im Hauptverzeichnis gibt es eine Datei Makefile.include. Diese Datei ist Teil des Contiki-Makefile-Systems. Sie wird innerhalb eines Contiki-Projektes aufgerufen und bindet, abhängig von der Konfiguration des Projektes, die richtigen Dateien des Contiki-Systems ein.

\subsection{Übersetzung eines Contiki-Programms}

Ein Programm wird in Contiki mithilfe des Befehls "`make"' übersetzt. Am Beispiel des Projekts webserver-ipv6-raven soll exemplarisch gezeigt werden, wie das Makefile System funktioniert. Durch den Befehl "`make"' wird die Datei Makefile im gleichen Verzeichnis abgearbeitet.

\begin{lstlisting}[caption=Auszug aus examples/webserver-ipv6-raven/Makefile]
ifndef TARGET
  TARGET=avr-raven
  MCU=atmega1284p
endif
all:
  ${MAKE} -f Makefile.webserver TARGET=$(TARGET) NOAVRSIZE=1 webserver6.elf
\end{lstlisting}

Hier wird das TARGET, also die Plattform, und die MCU, die Microcontroller Unit, gesetzt und dann die Datei Makefile.webserver aufgerufen. Dabei wird der Parameter NOAVRSIZE gesetzt, um beim Übersetzen eine zusätzliche Ausgabe zur Speicherbelegung (avr-size) zu unterdrücken. Das Programm wird als Datei webserver6.elf erstellt.

\begin{lstlisting}[caption=Auszug aus examples/webserver-ipv6-raven/Makefile.webserver]
all: webserver6
APPS=raven-webserver raven-lcd-interface
UIP_CONF_IPV6=1
CONTIKI = ../..
include $(CONTIKI)/Makefile.include
\end{lstlisting}

In der Datei Makefile.webserver werden die Applikationen raven-webserver und raven-lcd-interface über die Variable APPS eingebunden. Die Compiler Variable \texttt{UIP\_CONF\_IPV6} wird gesetzt, um IPv6 zu aktivieren, weiterhin wird das Haupt-Makefile \texttt{Makefile.include} eingebunden.

\begin{lstlisting}[caption=Auszug aus examples/webserver-ipv6-raven/webserver6.c]
#include "webserver-nogui.h"
/*--------------------------------------------------------------------*/
AUTOSTART_PROCESSES(&webserver_nogui_process);
/*--------------------------------------------------------------------*/
\end{lstlisting}

In der Datei webserver6.c wird ausgewählt, welche Contiki-Prozesse automatisch gestartet werden sollen. In unserem Beispiel ist das der Prozess "`webserver\_nogui\_process"'. Dieser Prozess ist Teil der Applikation raven-webserver.



\subsection{Programmieren eines Mikrocontrollers}


Durch Übersetzung des Contiki-Beispielprojektes webserver-ipv6-raven wird eine Datei "`webserver6.elf"' im ELF Format erzeugt. Hiervon wird eine Kopie "`webserver6-avr-raven.elf"' erstellt. Diese Datei enthält Informationen darüber, was in den Flash und in den EEPROM des AVR Mikrocontrollers geladen werden muss. Ebenfalls beinhaltet es Informationen über das Setzen der Fuse Bits. Fuse Bits sind Einstellungen des Mikrocontrollers, die nicht von der Software geändert werden können. Sie schalten gewisse Funktionen, zum Beispiel woher die Taktfrequenz bezogen wird, ein oder aus.

\begin{lstlisting}[caption=Auszug aus examples/webserver-ipv6-raven/Makefile]
TARGET=avr-raven
MCU=atmega1284p
OUTFILE=webserver6-$(TARGET)
avr-objcopy -O ihex -R .eeprom -R .fuse -R .signature \
            $(OUTFILE).elf $(OUTFILE).hex
avr-size -C --mcu=$(MCU) $(OUTFILE).elf
\end{lstlisting}

Durch zusätzliche Befehle im Makefile wird eine Datei "`webserver6-avr-raven.hex"' erzeugt. Diese Datei enthält den Inhalt, der in den Flash geschrieben werden soll, im Intel-HEX-Format. Mit dem "`avr-size"'-Befehl wird die Anzahl der Bytes angezeigt, die im Flash, im RAM und im EEPROM benötigt werden. Dies kann mit dem zur Verfügung stehenden Speicher verglichen werden.

\begin{lstlisting}[caption=Ausgabe vom Befehl "`avr-size"']
AVR Memory Usage
----------------
Device: atmega1284p

Program:   70874 bytes (54.1% Full)
(.text + .data + .bootloader)

Data:      13013 bytes (79.4% Full)
(.data + .bss + .noinit)

EEPROM:       63 bytes (1.5% Full)
(.eeprom)
\end{lstlisting}

Durch Hinzufügen eines zusätzlichen Befehls ins Makefile kann eine Datei "`webserver6-avr-raven\_eeprom.hex"' erzeugt werden. Diese Datei enthält dann den Inhalt im Intel-HEX-Format, der in den EEPROM geschrieben werden soll. Mit den beiden Dateien im Intel-HEX-Format ist es möglich, den Mikrocontroller mit einem Programmiergerät zu beschreiben, das kein ELF Format lesen kann.

\begin{lstlisting}[caption=Befehl um eeprom.hex zu erzeugen]
avr-objcopy -O ihex -j .eeprom \
            -set-section-flags=.eeprom="alloc,load" --change-section-lma \
            .eeprom=0 $(OUTFILE).elf $(OUTFILE)_eeprom.hex
\end{lstlisting}


Mittels des Programms Atmel Studio 6 werden wahlweise die erzeugten Dateien im Intel-HEX-Format oder die erzeugte Datei im ELF Format in den Flash und in den EEPROM des Mikrocontrollers programmiert. Zu Beginn wurde das Beispielprojekt webserver-ipv6-raven auf den Mikrocontroller AT-Mega1284P eines Atmel Ravenboard programmiert. Dabei wurde die Programmierschnittstelle ISP und das Programmiergerät Atmel STK500 verwendet.

Später bei der entwickelten Hardware wurde die Programmierschnittstelle JTAG und das Programmiergerät Atmel JTAGICE3 verwendet.



% !TEX root = ../Thesis.tex
%%
%%  Hochschule für Technik und Wirtschaft Berlin --  Abschlussarbeit
%%
%% Kapitel 3 - Methodik und Anforderungsanalyse
%%
%%

\chapter{Stand der Technik} \label{Stand_der_Technik}
In diesem Kapitel wird im ersten Schritt die historische Entwicklung des horizontalen Netzwerkscannings betrachtet.
Daraufhin werden in der Forschung etablierte Scanner sowie alternative Ansätze vorgestellt, diskutiert und
die resultierenden Nachteile betrachtet. 
Es folgt ein kurzer Überblick über weitere relevante Forschungsarbeiten zu relevanten Forschungssträngen
sowie die Auswahl der Scanner, welche später als Vergleichsobjekte dienen.

\section{Historische Entwicklung des horizontalen Netzwerkscannings} \label{Ch3_Historische_Entwicklung}
Ursprüngliche Netzwerkscanner wie Nmap \cite{Lyon_2010} wurden primär für die vertikale Analyse einzelner \eng{Hosts} oder 
kleiner Netzwerke konzipiert. Sie arbeiten teils zustandsbehaftet, was bedeutet, dass für jede 
ausgesendete Anfrage ein eigener Eintrag im Arbeitsspeicher verwaltet wird, um den Verbindungsstatus abzubilden. 
Bei Internet-weiten Scans führt dieser Ansatz jedoch schnell zur Erschöpfung der Systemressourcen und limitiert die 
Scan-Geschwindigkeit drastisch. Ein vollständiger Scan des Internets benötigte mit diesen Methoden 
oft Wochen oder Monate \cite{Durumeric_Wustrow_Halderman}.

Der entscheidende Durchbruch gelang 2013 mit der Veröffentlichung von ZMap durch Durumeric et al. 
Mithilfe eines radikalen Architekturwechsels hin zum zustandslosen Scanning 
konnte die Geschwindigkeit soweit gesteigert werden, dass 97\,\% der theoretischen Geschwindigkeit 
von Gigabit-Ethernet erreicht wurden. Dies ermöglichte erstmals Scans des gesamten IPv4-Adressraums 
in unter 45 Minuten von einem einzelnen Rechner aus \cite{Durumeric_Wustrow_Halderman}. Spätere Arbeiten, wie 
Zippier ZMap, optimierten diesen Ansatz weiter, um auch bis zu 10-Gbps-Leitungen auszulasten \cite{Adrian_Durumeric_Singh_Halderman}
und somit die anhaltende Relevanz des ZMap-Projektes zu unterstreichen.

\subsection{Der Standard Scanner: ZMap} \label{Ch3_S1_ZMap}
In der wissenschaftlichen Literatur gilt ZMap \cite{Durumeric_Wustrow_Halderman} als der De-facto-Standard und als das primäre Vergleichsobjekt für 
internetweite Scans. In einer Retrospektive aus dem Jahr 2024 stellen Durumeric et al. fest, dass ZMap die Art und Weise, wie Internetmessungen 
durchgeführt werden, fundamental verändert hat. Mit über 1.200 wissenschaftlichen Zitationen und der Nutzung als 
Basis für kommerzielle Sicherheitsanalysen (z.\,B. Censys) ist es das am weitesten verbreitete Werkzeug seiner Art \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

Der Kern der Leistungsfähigkeit von ZMap lässt sich auf drei wesentliche Implementierungsentscheidungen zurückführen:

\begin{itemize} 
	\item \textbf{Effiziente \eng{I/O}-Schnittstellen:} ZMap nutzt standardmäßig \texttt{AF\_PACKET} in Kombination mit \eng{Memory Mapping} (\texttt{mmap}), 
    um den \eng{Overhead} des Kopierens zwischen Kernel und \eng{User-Space} zu reduzieren. Zwar zeigten Erweiterungen wie 
    Zippier ZMap \cite{Adrian_Durumeric_Singh_Halderman}, dass durch spezialisierte Treiber wie \texttt{PF\_RING ZC} (\eng{Zero-Copy}) 
    noch höhere Geschwindigkeiten möglich sind, jedoch weisen die Autoren darauf 
    hin, dass solche externen Treiber oft Wartungsprobleme und Inkompatibilitäten mit sich bringen. 
    Daher setzt die aktuelle Version von ZMap primär auf universell verfügbare Linux-Schnittstellen, 
    auch wenn diese \eng{Performance}-technisch limitiert sind \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

    \item \textbf{Zustandslose Architektur:} ZMap nutzt das Prinzip der \texttt{SYN}-Cookies, um keinen Zustand 
    für ausgehende Verbindungen im Arbeitsspeicher halten zu müssen. 

    \item \textbf{Adressgenerierung mittels zyklischer Gruppen:} ZMap nutzt zyklische multiplikative Gruppen 
    modulo $p$ (wobei $p$ eine Primzahl $> 2^{32}$ ist). Dies ermöglicht eine pseudozufällige Permutation des gesamten 
    IPv4-Adressraums, was nötig ist, um Zielnetzwerke nicht zu überlasten. \cite{Durumeric_Wustrow_Halderman}.
\end{itemize}

\section{Alternative Implementierungsansätze} \label{Ch3_Alternative_Implementierungsansätze}
Neben der reinen \eng{Socket}-Programmierung und klassischen \eng{Raw-Sockets} haben sich weitere, teils modernere 
Techniken und Scanner-Architekturen aufgetan. Beispielsweise mithilfe von:

\begin{itemize} 
\item \textbf{\eng{Kernel-Bypass} mit \texttt{DPDK}:} Das Data Plane Development Kit (\texttt{DPDK}) erlaubt es Anwendungen, die Netzwerkkarte 
direkt aus dem \eng{User-Space} anzusprechen und den Kernel komplett zu umgehen. Abu Bakar und Kijsirikul zeigen, dass 
\texttt{DPDK}-basierte Scanner extrem hohe Raten erzielen können \cite{Abu_Bakar_Kijsirikul_2023}. Der Nachteil ist jedoch 
die hohe Komplexität, die exklusive Belegung von CPU-Kernen und die schwierige Integration in bestehende Systemumgebungen \cite{Høiland-Jørgensen_Brouer_Borkmann_Fastabend_Herbert_Ahern_Miller_2018}.

\item \textbf{Eigener TCP-Stack im \eng{User-Space} (Masscan):} Der Scanner Masscan \cite{Graham_2026} umgeht den Flaschenhals des Betriebssystems 
mithilfe eines eigenen TCP-Stacks im \eng{User-Space}. Dies erlaubt es dem Scanner, die Statusverwaltung und das Timing von Paketen 
komplett unabhängig vom Kernel-\eng{Scheduler} zu steuern. Der \eng{Scheduler} ist normalerweise dafür verantwortlich, die Rechenzeit der 
CPU auf die laufenden Prozesse zu verteilen \cite[S.~737]{Kerrisk_2018}. Die dabei entstehenden \eng{Context Switches} können das präzise Timing von Hochleistungsanwendungen 
stören. Dadurch kann Masscan deutliche \eng{Performance}-Gewinne gegenüber ZMap erreichen \cite{Pittman_2023}.

\item \textbf{\eng{Hardware-Offloading} und \eng{SmartNICs}:} Um die CPU des \eng{Host}-Systems zu entlasten, lagert IMap 
die Scan-Logik direkt auf die Netzwerkhardware aus. Durch den Einsatz von programmierbaren Switches oder \eng{SmartNICs} können Pakete 
bereits auf der Netzwerkkarte generiert und Antworten gefiltert werden, bevor sie überhaupt die CPU erreichen.
Dies erfordert jedoch spezialisierte Hardware.
In dieser Untersuchung wurde mit Raten von 40Gbps getestet, wobei jedoch Raten von einem Terabit oder mehr laut Li et al. theoretisch möglich wären. \cite{Li_Zhang_Guo_Bao_Xu_Hu_Li_2022}   
\end{itemize}

\section{Weitere relevante wissenschaftliche Arbeiten} \label{Ch3_Weitere_Arbeiten}
Der Forschungsstand zu horizontalen Hochleistungs-Netzwerkscannern wurde bereits in den vorherigen Abschnitten \cref{Ch3_Historische_Entwicklung,Ch3_Alternative_Implementierungsansätze} aufgegriffen. Ergänzend dazu ist noch anzubringen, dass nach bestehenden Ansätzen zur Kernel-Umgehung
die Arbeit zu \texttt{XDP} (\eng{eXpress Data Path}) einen Paradigmenwechsel darstellt. Zuvor genutzte Umgehungsstrategien waren unter anderem Netmap \cite{Rizzo}, 
welches bereits 2012 Konzepte wie \eng{Shared Memory}\footnote{Zwischen \eng{User-Space} und \eng{Kernel-Space} geteilter Speicher} 
und \eng{Zero-Copy} einführte, aber den Netzwerkstack eher ersetzte, statt ihn zu komplementieren, oder \texttt{DPDK} (siehe \cref{Ch3_Alternative_Implementierungsansätze}). 
Høiland-Jørgensen et al. zeigen, dass mit \texttt{XDP} durch eine programmierbare 
Paketverarbeitung im Kernel-Treiber eine mit \texttt{DPDK} vergleichbare \eng{Performance} erreicht werden kann, ohne die Integration in das Betriebssystem 
aufzugeben \cite{Høiland-Jørgensen_Brouer_Borkmann_Fastabend_Herbert_Ahern_Miller_2018}. 

Zwei Studien vergleichen \texttt{SYN}-Scanner \cite{Pittman_2023} \cite{Taupaani_Harwahyu_2025}, fokussieren sich aber eher auf die Trefferrate, welche in der Arbeit
nicht priorisiert wird (siehe \cref{Abgrenzung}). Außerdem ist die Gestaltung der Testumgebung bei beiden Arbeiten nicht auf Hochleistungs-Szenarien ausgelegt. 

Die Eignung von Rust für hochperformante Netzwerkprogrammierung wird in mehreren wissenschaftlichen Arbeiten evaluiert. Sagramoni et al.
schrieben eine Netzwerkbibliothek in Rust und verglichen sie mit der ursprünglichen C-Bibliothek \cite{Sagramoni_Lettieri_Procissi_2024}.
Gonzalez et al. entwickelten einen UDP Treiber für Linux und verglichen diesen mit einem ähnlichen C-Treiber \cite{Gonzalez2023Takeaways}.
Moon et al. erstellten einen \eng{NAT} (Network Address Translator) und testeten den Durchsatz \cite{Moon2017Toward}. 
Alle kommen zu dem Ergebnis, dass Rust sich für die \eng{Low-Level}-Netzwerkprogrammierung gut eignet und eine minimal niedrigere \eng{Performance}  
verglichen mit der aktuellen Standardsprache in diesem Bereich - C - aufweist. Emmerich et al. verglichen Rust mit
einer Vielzahl von anderen Sprachen, indem sie einen Netzwerktreiber in jeder der untersuchten Sprachen schrieben und 
diese anschließend miteinander verglichen. Dabei stellte sich Rust aufgrund seiner Sicherheitsgarantien und Performanz
als erste Wahl für zukünftige Treiber-Projekte heraus \cite{Emmerich_Ellmann_Bonk_Egger_Sánchez-Torija_Günzel_Di_Luzio_Obada_Stadlmeier_Voit_et_al._2019}.

Weitere Arbeiten beschäftigen sich mit dem Thema Sicherheit von Rust verglichen mit anderen Programmiersprachen und kamen zum
einheitlichen Ergebnis, dass Rust umfangreiche Sicherheitsgarantien mitbringt, die man so von keiner anderen gängigen Sprache
erhält \cite{Bugden_Alahmar_2022} \cite{bugden2022safety} \cite{Balasubramanian2017System}.

\section{Vergleichsobjekte für die Evaluation}
Um die Eignung der Implementierung in seiner Funktion als Performanz-orientierter \texttt{SYN}-Scanner aussagekräftig evaluieren zu können,
wird er im Evaluationsteil der Arbeit mit folgenden Scannern verglichen

\begin{itemize}
    \item \textbf{Wissenschaftlicher Standard:} Als primäres Vergleichsobjekt dient ZMap \cite{Durumeric_Wustrow_Halderman}, 
    da dieser die historische Basis des Internetscannings darstellt (siehe \cref{Ch3_S1_ZMap}). Da ZMap in C geschrieben ist und auf 
    klassischen Linux-Schnittstellen basiert, dient er als \eng{Baseline}, um zu untersuchen, ob die im Lösungsansatz gewählte Kombination 
    aus Rust und \texttt{XDP} trotz der Sicherheitsgarantien mit der etablierten Referenz konkurrieren kann.
    \item \textbf{Performance-Referenz:} Ergänzend wird Masscan \cite{Graham_2026} herangezogen. Dieser gilt durch seinen 
    eigenen \eng{User-Space}-Stack (siehe \cref{Ch3_Alternative_Implementierungsansätze}) als einer der schnellsten verfügbaren Scanner. 
    Dieser Vergleich ist sinnvoll, um die Effizienz der \texttt{XDP}-basierten Lösung gegenüber einem hochoptimierten C-Ansatz einzuordnen.
\end{itemize}

\section{Nachteile bisheriger Ansätze}
\subsection{Nachteile C-basierter Ansätze}
Obwohl ZMap und ähnliche Hochleistungsscanner (wie Masscan oder \texttt{DPDK}-Scanner) extrem effizient sind, 
basieren sie fast ausschließlich auf der Programmiersprache C. Diese technologische Monokultur bringt jedoch signifikante Nachteile mit sich.

Ein zentraler Nachteil ist die fehlende intrinsische Speichersicherheit von C \cite{van_Oorschot_2023}. Da die Sprache dem Entwickler die volle 
Verantwortung für die Speicherverwaltung überträgt, führen menschliche Fehler häufig zu schwerwiegenden Sicherheitslücken. 
Schwachstellen wie \eng{Buffer Overflows} in C/C++-basierten Systemen zählen nach wie 
vor zu den häufigsten Ursachen für Sicherheitslücken \cite{Al_Boghdady_Wassif_El_Ramly_2021}. 

Darüber hinaus geht die Leistungsfähigkeit von C oft zu Lasten der Wartbarkeit und Entwicklungseffizienz \cite{Costanzo_Rucci_Naiouf_Giusti_2021}. 
Um maximale Durchsatzraten zu erzielen, sind in C häufig komplexe, manuelle Optimierungen notwendig. Costanzo et al. heben
hervor, dass die Entwicklung von korrektem und effizientem C-Code im Vergleich zu Rust-Code
einen signifikant höheren Programmieraufwand erfordert, insbesondere wenn komplexe Nebenläufigkeit 
umgesetzt werden soll \cite{Costanzo_Rucci_Naiouf_Giusti_2021}. Selbst die Autoren von 
ZMap sagen in ihrer Retrospektive explizit, dass sie für eine heutige Implementierung ihres Scanners Rust 
wählen würden, um die Wartbarkeit und Sicherheit der Codebasis langfristig zu gewährleisten \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

Ein weiterer wesentlicher Nachteil bisheriger Hochleistungsansätze (wie \texttt{DPDK} oder \texttt{PF\_RING}) ist ihre fehlende Integration 
in den Linux-\eng{Mainline-Kernel}. Sie erfordern oft proprietäre Treiber oder Kernel-Module, die das Sicherheitssystem des Kernels 
umgehen und bei Updates zu Inkompatibilitäten führen können \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}. Durumeric et al. merken an, 
dass die Einführung und Wartung von \texttt{PF\_RING} für ZMap über die Jahre eine erhebliche Hürde darstellte \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}. 
\texttt{XDP} füllt diese Lücke, indem es \eng{High-Performance}-Paketverarbeitung direkt im Kernel ermöglicht, ohne dessen Sicherheit und Kompatibilität zu kompromittieren.

\subsection{Lösungsansatz}
Die Nutzung von Rust stellt einen vielversprechenden Lösungsansatz dar, 
da sie Speichersicherheit bereits zur Kompilierzeit garantiert, in der Lage ist, eine mit C vergleichbare Geschwindigkeit zu erreichen, 
und die Sprache durch ihr striktes Typ- und Besitzmodell ganze Klassen von Fehlern (wie \eng{Data Races}) eliminiert (siehe \cref{rust}). 
Zusätzlich löst die Nutzung moderner Kernel-Funktionen wie \texttt{XDP} und \texttt{eBPF} den Nachteil der fehlenden Kernelintegration 
für die Hochleistungspaketverarbeitung.

Die Kombination dieser Techniken und Werkzeuge stellt in dem Kontext des horizontalen High-Speed-Netzwerkscannings
eine Forschungslücke dar, die in dieser Arbeit untersucht wird.

% !TEX root = ../Thesis.tex
%%
%%  Hochschule für Technik und Wirtschaft Berlin --  Abschlussarbeit
%%
%% Kapitel 3 - Methodik und Anforderungsanalyse
%%
%%

\chapter{Stand der Technik} \label{Stand_der_Technik}
In diesem Kapitel wird im ersten Schritt die historische Entwicklung des horizontalen Netzwerkscannings betrachtet.
Daraufhin werden in der Forschung etablierte Scanner und alternative Ansätze vorgestellt und diskutiert, und
die resultierende Problematik betrachtet. 
Es folgt ein kurzer Überblick über weitere relevante Forschungsarbeiten zu ebenfalls relevanten Forschungssträngen
sowie die Auswahl der Scanner, welche später als Vergleichsobjekte dienen vorgestellt.

\section{Historische Entwicklung des horizontalen Netzwerk-Scannings} \label{Ch3_Historische_Entwicklung}
Ursprüngliche Netzwerkscanner wie \textit{Nmap} \cite{Lyon_2010} wurden primär für die vertikale Analyse einzelner Hosts oder 
kleiner Netzwerke konzipiert. Sie arbeiten teils Zustands-behaftet, was bedeutet, dass für jede 
ausgesendete Anfrage ein eigener Eintrag im Arbeitsspeicher verwaltet wird, um den Verbindungsstatus abzubilden. 
Bei Internet-weiten Scans führt dieser Ansatz jedoch schnell zur Erschöpfung der Systemressourcen und limitiert die 
Scan-Geschwindigkeit drastisch. Ein vollständiger Scan des Internets benötigte mit diesen Methoden 
oft Wochen oder Monate \cite{Durumeric_Wustrow_Halderman}.

Der entscheidende Durchbruch gelang 2013 mit der Veröffentlichung von \textit{ZMap} durch Durumeric et al. 
Mithilfe eines radikalen Architekturwechsels hin zum zustandslosen Scanning 
konnte die Geschwindigkeit so weit gesteigert werden, dass 97 \% der theoretischen Geschwindigkeit 
vom Gigabit-Ethernet erreicht wurden. Dies ermöglichte erstmals Scans des gesamten IPv4-Adressraums 
in unter 45 Minuten von einem einzelnen Rechner aus \cite{Durumeric_Wustrow_Halderman}. Spätere Arbeiten, wie 
\textit{Zippier ZMap}, optimierten diesen Ansatz weiter, um auch bis zu 10-Gbps Leitungen auszulasten \cite{Adrian_Durumeric_Singh_Halderman}
und somit die anhaltende Relevanz des \textit{ZMap}-Projektes zu unterstreichen.

\subsection{Der Standard Scanner: ZMap} \label{Ch3_S1_ZMap}
In der wissenschaftlichen Literatur gilt \textit{ZMap} \cite{Durumeric_Wustrow_Halderman} als der De-facto-Standard und als das primäre Vergleichsobjekt für 
internetweite Scans. In einer Retrospektive aus dem Jahr 2024 stellen Durumeric et al. fest, dass \textit{ZMap} die Art und Weise, wie Internetmessungen 
durchgeführt werden, fundamental verändert hat. Mit über 1.200 wissenschaftlichen Zitationen und der Nutzung als 
Basis für kommerzielle Sicherheitsanalysen (z. B. \textit{Censys}) ist es das am weitesten verbreitete Werkzeug seiner Art \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

Der Kern der Leistungsfähigkeit von \textit{ZMap} lässt sich auf drei wesentliche Implementierungsentscheidungen zurückführen:

\begin{itemize} 
	\item \textbf{Effiziente I/O-Schnittstellen:} \textit{ZMap} nutzt standardmäßig \texttt{AF\_PACKET} in Kombination mit \textit{Memory Mapping} (\texttt{mmap}), 
    um den \textit{Overhead} des Kopierens zwischen \textit{Kernel} und \textit{User-Space} zu reduzieren. Zwar zeigten Erweiterungen wie 
    \textit{Zippier ZMap} \cite{Adrian_Durumeric_Singh_Halderman}, dass durch spezialisierte Treiber wie \texttt{PF\_RING ZC} (\textit{Zero Copy}) 
    noch höhere Geschwindigkeiten möglich sind, jedoch weisen die Autoren darauf 
    hin, dass solche externen Treiber oft Wartungsprobleme und Inkompatibilitäten mit sich bringen. 
    Daher setzt die aktuelle Version von \textit{ZMap} primär auf universell verfügbare Linux-Schnittstellen, 
    auch wenn diese performancetechnisch limitiert sind \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

    \item \textbf{Zustandslose Architektur:} \textit{ZMap} nutzt das Prinzip der \texttt{SYN}-Cookies \ref{Grundlagen}, um keinen Zustand 
    für ausgehende Verbindungen im Arbeitsspeicher halten zu müssen. 

    \item \textbf{Adressgenerierung mittels zyklischer Gruppen:} \textit{ZMap} nutzt zyklische multiplikative Gruppen 
    modulo $p$ (wobei $p$ eine Primzahl $> 2^{32}$ ist). Dies ermöglicht eine pseudozufällige Permutation des gesamten 
    IPv4-Adressraums, was nötig ist, um Zielnetzwerke nicht zu überlasten. \cite{Durumeric_Wustrow_Halderman}.
\end{itemize}

\section{Alternative Implementierungsansätze} \label{Ch3_Alternative_Implementierungsansätze}
Neben der reinen Socket-Programmierung und klassischen Raw-Sockets haben sich weitere, teils modernere 
Technologien und Scanner-Architekturen aufgetan. Beispielsweise mithilfe von:

% TODO hier teilweise Quellen ergänzen
\begin{itemize} 
\item \textbf{\textit{Kernel-Bypass} mit \texttt{DPDK}:} Das \textit{Data Plane Development Kit} (\texttt{DPDK}) erlaubt es Anwendungen, die Netzwerkkarte 
direkt aus dem \textit{User-Space} anzusprechen und den Kernel komplett zu umgehen. Abu Bakar und Kijsirikul zeigen, dass 
\texttt{DPDK}-basierte Scanner extrem hohe Raten erzielen können \cite{Abu_Bakar_Kijsirikul_2023}. Der Nachteil ist jedoch 
die hohe Komplexität, die exklusive Belegung von CPU-Kernen und die schwierige Integration in bestehende Systemumgebungen.

\item \textbf{Eigener TCP-Stack im \textit{User-Space} (\textit{Masscan}):} Der Scanner \textit{Masscan} \cite{Graham_2026} umgeht den Flaschenhals des Betriebssystems 
mithilfe eines eigenem, TCP-Stack im \textit{User-Space}. Dies erlaubt es dem Scanner, die Statusverwaltung und das Timing von Paketen 
komplett unabhängig vom \textit{Kernel-Scheduler} \footnote{TODO} zu steuern. Dadurch kann \textit{Masscan} deutliche Performancegewinne gegenüber
\textit{ZMap} erreichen \cite{Pittman_2023}.

\item \textbf{Hardware-Offloading und \textit{SmartNICs}:} Um die CPU des Host-Systems zu entlasten, lagert \textit{IMap} 
die Scan-Logik direkt auf die Netzwerkhardware aus. Durch den Einsatz von programmierbaren Switches oder \textit{SmartNICs} können Pakete 
bereits auf der Netzwerkkarte generiert und Antworten gefiltert werden, bevor sie überhaupt die CPU erreichen \cite{Li_Zhang_Guo_Bao_Xu_Hu_Li_2022}. 
Dies erfordert jedoch spezialisierte Hardware.
In dieser Untersuchung wurde mit Raten von 40Gbps getestet, wobei jedoch Raten von einem Terabit oder mehr theoretisch
laut Li et al. möglich wären \cite{Li_Zhang_Guo_Bao_Xu_Hu_Li_2022}.   
\end{itemize}

\section{Weitere relevante wissenschaftliche Arbeiten} \label{Ch3_Weitere_Arbeiten}
% TODO aufzählen, welche weiteren relevanten Arbeiten es zu dem Thema gibt, welche Methodik und welche Erkenntnisse
Der Forschungsstand zu horizontalen Hochleistungs-Netzwerkscannern wurde bereits in den vorherigen Sektionen \ref{Ch3_Historische_Entwicklung} und 
\ref{Ch3_Alternative_Implementierungsansätze} aufgegriffen. Ergänzend dazu ist noch anzubringen, dass nach bestehenden Ansätzen zur Kernel-Umgehung
wie \textit{Netmap} \cite{Rizzo} welches bereits 2012 Konzepte wie \textit{Shared Memory} \footnote{Zwischen Userspace und Kernelspace geteilter Speicher} 
und \textit{Zero-Copy} einführte aber den Netzwerkstack eher ersetzte oder \textit{DPDK} (siehe \ref{Ch3_Alternative_Implementierungsansätze}), die Arbeit 
zu \texttt{XDP} (\textit{eXpress Data Path}) einen Paradigmenwechsel darstellt. Høiland-Jørgensen et al. zeigen, dass durch eine programmierbare 
Paketverarbeitung im Kernel-Treiber eine mit \textit{DPDK} vergleichbare Performance erreicht werden kann, ohne die Integration in das Betriebssystem 
aufzugeben \cite{Høiland-Jørgensen_Brouer_Borkmann_Fastabend_Herbert_Ahern_Miller_2018}. 

Zwei Studien vergleichen SYN-Scanner \cite{Pittman_2023} \cite{Taupaani_Harwahyu_2025}, fokussieren sich aber eher auf die Trefferrate, welche in der Arbeit
nicht priorisiert wird (\ref{Abgrenzung}). Außerdem ist die Gestaltung der Testumgebung ist bei beiden nicht auf Hochleistungs-Szenarien ausgelegt. 

Die Eignung von Rust für hochperformante Netzwerkprogrammierung wird in mehreren wissenschaftlichen Arbeiten evaluiert. Sagramoni et al.
schrieben eine Netzwerkbibliothek in Rust und verglichen sie mit der ursprünglichen C-Bibliothek \cite{Sagramoni_Lettieri_Procissi_2024}.
Gonzalez et al. entwickelten einen UDP Treiber für Linux und verglichen diesen mit einem ähnlichen C-Treiber \cite{Gonzalez2023Takeaways}.
Moon et al. erstellten einen \textit{NAT} (Network Address Translator) und testeten den Durchsatz \cite{Moon2017Toward}. 
Alle kommen zu dem Ergebnis, dass Rust sich für die \textit{low-level} Netzwerkprogrammierung gut eignet und eine minimal niedrigere Performance  
verglichen mit der aktuellen Standardsprache in diesem Bereich - C, aufweist. Emmerich et al. verglichen Rust mit
einer Vielzahl von anderen Sprachen, indem sie einen Netzwerktreiber in jeder der untersuchten Sprachen schrieben und 
diese anschließend miteinander verglichen. Dabei stellte sich Rust aufgrund seiner Sicherheitsgarantien und Performanz
als erste Wahl für zukünftige Treiber-Projekte heraus \cite{Emmerich_Ellmann_Bonk_Egger_Sánchez-Torija_Günzel_Di_Luzio_Obada_Stadlmeier_Voit_et_al._2019}.

Weitere Arbeiten beschäftigen sich mit dem Thema Sicherheit von Rust verglichen mit anderen Programmiersprachen und kamen zum
einheitlichen Ergebnis, dass Rust umfangreiche Sicherheitsgarantien mitbringt, die man so von keiner anderen gängigen Sprache
erhält \cite{Bugden_Alahmar_2022,bugden2022safety,Balasubramanian2017System}.

\section{Vergleichsobjekte für die Evaluation}
Um die Eignung der Implementierung in seiner Funktion als Performanz-orientierter SYN-Scanner aussagekräftig evaluieren zu können,
wird er im Evaluationsteil der Arbeit mit folgenden Scannern verglichen

% TODO ändern zu ZMap und Masscan
\begin{itemize}
    \item  \textbf{Vergleichsobjekt aus der Forschung:} Als Vergleichsobjekt aus der Forschung dient ZMap. Wie bereits in \ref{Ch3_S1_ZMap}
    gezeigt, repräsentiert er das Standard-Vergleichsobjekt aus der Forschung und ist gleichzeitig einer der zahlreichen Varianten, 
    welche in C geschrieben ist.
    \item  \textbf{Rust Alternative:} Um auch ein Vergleich mit bereits bestehende Alternativen in Rust aufzuzeigen ... TODO
    \item  \textbf{Alternative aus der Wirtschaft:} Da die Forschungsfrage unter anderem darauf abzielt die Eignung des implementierten
    Rust Scanners für den produktiven Einsatz zu untersuchen, soll dieser auch mit einem Scanner, welcher aktuell in der Wirtschaft
    genutzt wird, aber eigens in Go entwickelt wurde. Dies stärkt außerdem die Vergleichsbreite, da somit auch eine Sprache mit 
    automatischer Speicherverwaltung in den Vergleich integriert ist.
\end{itemize}

\section{Problematik bisheriger Ansätze}
\subsection{Problematik C-basierter Ansätze}
Obwohl \textit{ZMap} und ähnliche Hochleistungsscanner (wie \textit{Masscan} oder \texttt{DPDK}-Scanner) extrem effizient sind, 
basieren sie fast ausschließlich auf der Programmiersprache C. Diese technologische Monokultur bringt jedoch signifikante Nachteile mit sich.

Ein zentrales Problem ist die fehlende intrinsische Speichersicherheit von C [TODO]. Da die Sprache dem Entwickler die volle 
Verantwortung für die Speicherverwaltung überträgt, führen menschliche Fehler häufig zu schwerwiegenden Sicherheitslücken. 
Schwachstellen wie \textit{Buffer Overflows} in C/C++-basierten Systemen zählen nach wie 
vor zu den häufigsten Ursachen für Sicherheitslücken \cite{Al_Boghdady_Wassif_El_Ramly_2021}. 
% TODO recherchieren \cite{Al_Boghdady_Wassif_El_Ramly_2021}
% Besonders im Kontext von 
% Internet-Scannern, die massenhaft \textit{untrusted Input} aus potenziell maliziösen Quellen des offenen Internets verarbeiten, 
% stellt die Verwendung einer nicht speichersicheren Sprache ein erhebliches Risiko dar.
%
Darüber hinaus geht die Leistungsfähigkeit von C oft zu Lasten der Wartbarkeit und Entwicklungseffizienz \cite{Costanzo_Rucci_Naiouf_Giusti_2021}. 
Um maximale Durchsatzraten zu erzielen, sind in C häufig komplexe, manuelle Optimierungen notwendig. Costanzo et al. heben
hervor, dass die Entwicklung von korrektem und effizientem C-Code im Vergleich zu Rust-Code
einen signifikant höheren Programmieraufwand erfordert, insbesondere wenn komplexe Nebenläufigkeit 
umgesetzt werden soll \cite{Costanzo_Rucci_Naiouf_Giusti_2021}. Selbst die Autoren von 
\textit{ZMap} sagen in ihrer Retrospektive explizit, dass sie für eine heutige Implementierung ihres Scanners Rust 
wählen würden, um die Wartbarkeit und Sicherheit der Codebasis langfristig zu gewährleisten \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}.

\subsection{Problematik alternativer Ansätze}
Ein weiteres wesentliches Problem bisheriger Hochleistungsansätze (wie \texttt{DPDK} oder \texttt{PF\_RING}) ist ihre fehlende Integration 
in den \textit{Linux-Mainline-Kernel}. Sie erfordern oft proprietäre Treiber oder Kernel-Module, die das Sicherheitssystem des Kernels 
umgehen und bei Updates zu Inkompatibilitäten führen können [TODO]. Durumeric et al. merken an, dass die Wartung solcher 
spezialisierten Treiber für \textit{ZMap} über die Jahre eine erhebliche Hürde darstellte \cite{Durumeric_Adrian_Stephens_Wustrow_Halderman_2024}. \texttt{XDP} 
füllt diese Lücke, indem es High-Performance-Paketverarbeitung direkt im Kernel ermöglicht, ohne dessen Sicherheit und Kompatibilität zu kompromittieren.

% TODO Probleme von Go bzw anderen Sprachen hier nochmal aufbringen
\subsection{Lösungsansatz}
Die Nutzung von Rust stellt eine vielversprechende Lösung dar, 
da sie Speichersicherheit bereits zur Kompilierzeit garantiert, in der Lage ist, eine mit C vergleichbare Geschwindigkeit zu erreichen, 
und durch sein striktes Typ- und Besitzmodell ganze Klassen von Fehlern (wie \textit{Data Races}) eliminiert (siehe \ref{rust}). 
Zusätzlich löst die Nutzung von \texttt{XDP} und \texttt{eBPF} das Problem der fehlenden Kernelintegration für die 
Hochleistungspaketerarbeitung.

Die Kombination dieser Technologien und Werkzeuge stellt in dem Kontext des horizontalen \textit{high-speed} Netzwerk-Scannings
eine Forschungslücke dar, die in dieser Arbeit untersucht wird.


% !TEX root = ../Thesis.tex
%%
%%  Hochschule für Technik und Wirtschaft Berlin --  Abschlussarbeit
%%
%% Kapitel 4 - Konzeption und Implementierung
%%
%%

\chapter{Anforderungsanalyse und Methodik} \label{Methodik}
Dieses Kapitel definiert die funktionalen und nicht-funktionalen Anforderungen an den zu entwickelnden Portscanner, 
beschreibt das gewählte Vorgehensmodell zur Umsetzung in Rust und legt das Untersuchungsdesign für die anschließende Evaluation fest.

\section{Anforderungsanalyse} \label{Anforderungen}

\subsection{Funktionale Anforderungen} \label{Anforderungen.fa}
Die funktionalen Anforderungen definieren das Verhalten des Systems und die logischen Operationen, die der Scanner ausführen muss, 
um einen korrekten \texttt{SYN}-Scan durchzuführen.

\begin{itemize} 
    \item \textbf{/F-01/ \phantomsection\label{req:F-01} Konstruktion valider \texttt{TCP-SYN}-Pakete:} Das System muss in der Lage sein, rohe TCP-Pakete so zu konstruieren, 
    dass \texttt{IP}-Header und \texttt{TCP}-Header (inklusive \texttt{SYN}-Cookie) korrekt manuell gesetzt und die Prüfsummen korrekt berechnet werden,
    um vom Zielsystem als legitime Verbindungsanfragen akzeptiert zu werden. 

    \item \textbf{/F-02/ \phantomsection\label{req:F-02} Senden von Paketen:} Das System muss in der Lage sein, TCP Pakete an andere Zielsysteme zu senden. 
    
    \item \textbf{/F-03/ \phantomsection\label{req:F-03} Empfang von Paketen:} Das System muss in der Lage sein, eingehende Netzwerkpakete
    abzufangen und zu untersuchen.

    \item \textbf{/F-04/ \phantomsection\label{req:F-04} Zustandsloses Scanning:} Zwischen den Sende- und Empfangskomponenten darf keine Kommunikation über die Zielsysteme
    bestehen, sodass kein Zustand über bereits kontaktierte Zielsysteme gespeichert wird.

    \item \textbf{/F-05/ \phantomsection\label{req:F-05} Validierung eingehender Antworten:} Die Empfangskomponente muss eingehende \texttt{SYN-ACK}-Pakete validieren. 
    Dafür muss der Hash-Werte des \texttt{SYN}-Cookies korrekt erstellt und mit dem aus der \textit{Acknowledgement Number} extrahierten Wert verglichen werden.

    \item \textbf{/F-06/ \phantomsection\label{req:F-06} Schließen der Verbindung auf Zielsystem:} Nach der Identifikation eines offenen Ports, sollte der Scanner 
    ein \texttt{RST}-Paket senden, um die halb-offene Verbindung auf dem Zielsystem sauber zu schließen und Ressourcenfreigabe zu ermöglichen.

    \item \textbf{/F-07/ \phantomsection\label{req:F-07} Endausgabe und Vermeidung von Duplikaten:} Die Endausgabe muss die ausgewerteten Scanergebnisse inklusive IP-Adresse und Ziel-Port
    der offenen Zielsysteme enthalten und muss von Duplikaten bereinigt sein.

    \item \textbf{/F-08/ \phantomsection\label{req:F-08} Durchsatzlimitierung (\textit{Rate Limiting}):} Das Programm muss in der Lage sein, eine angegebene Durchsatzrate (in Byte pro Sekunde)
    nicht zu überschreiten, sodass eine konsistente Performanz-Messung möglich ist.

    \item \textbf{/F-9/ \phantomsection\label{req:F-09} Anpassung an bestehende Infrastruktur:} Das Programm muss die zu scannenden Ziel-IP-Adressen aus dem \textit{Standard Input}
    des Programmes entnehmen, um in die Infrastruktur des Unternehmens, welches diese Arbeit begleitet, zu passen.

    % TODO besser formulieren
    \item \textbf{/F-10/ \phantomsection\label{req:F-10} Linux native Technologien:} Das Programm soll keine Technologien nutzen, die nicht aus dem Ökosystem des Linux Kernels selbst
    stammen, um die Zukunftssicherheit und Unterstützung der genutzten Technologie zu untermauern.
    
\end{itemize}

\subsection{Nicht-funktionale Anforderungen}
Die nicht-funktionalen Anforderungen stellen Qualitätsanforderungen dar und leiten sich primär aus dem Forschungsziel,
der Performance-Maximierung und der Verwendung von Rust ab. 

\begin{itemize} 
\item \textbf{/NF-01/ \phantomsection\label{req:NF-01} Maximierung des Durchsatzes:} Das System soll in der Lage sein, die verfügbare Bandbreite einer 
Standard-Gigabit-Schnittstelle bestmöglich auszunutzen. Zielgröße ist ein Sende-Durchsatz im mindestens fünfstelligen Paket-pro-Sekunde-Bereich, 
um mit etablierten Tools vergleichbar zu sein.

% ist das wirklich nicht funktional?
\item \textbf{/NF-02/ \phantomsection\label{req:NF-02} Asynchrone Architektur:} Die Anwendung muss Gebrauch von Lastverteilenden Maßnahmen in Form
von nebenläufiger Programmierung machen, um die Auslastung zu verteilen und Performance somit zu steigern.

\item \textbf{/NF-03/ \phantomsection\label{req:NF-03} Nutzung moderner Kernel-Mechanismen:} 
    Zur Steigerung der Performance und Forschungsrelevanz sollen fortschrittliche Linux-Mechanismen zur Paketverarbeitung, 
    spezifisch \texttt{AF\_XDP} oder \texttt{eBPF}, evaluiert und implementiert werden.

\item \textbf{/NF-04/ \phantomsection\label{req:NF-04} Speichersicherheit:} 
Die Gesamtarchitektur soll die Sicherheitsgarantien von Rust wahren. \texttt{unsafe}-Blöcke können, falls nötig, genutzt werden 
(z.B. für systemnahe Netzwerkoperationen) sollten aber möglichst vermieden oder durch die Nutzung von externen Bibliotheken  
ersetzt werden, da diese intern \texttt{unsafe}-Blöcke häufig sicher kapseln \cite{RustBelt}.

\item \textbf{/NF-05/ \phantomsection\label{req:NF-05} Minimale Ressourcennutzung:} Die Architektur und gewählten Technologien sollten die Ressourcennutzung
(CPU-Zeit, RAM Verbrauch) neben der Durchsatzgeschwindigkeit nach \hyperref[req:NF-01]{/NF-01/} priorisieren und somit minimieren.
Keine der beiden Anforderungen darf aufgrund der anderen stark vernachlässigt werden. 
\end{itemize}

% TODO das ändern! Keine zwei Stufen mehr sondern ein Architektonisches Projekt
\section{Vorgehensmodell der Entwicklung}
Für die Realisierung wird ein evaluationsgetriebener, prototypischer Ansatz gewählt. Aufgrund der Komplexität asynchroner 
Netzwerkprogrammierung, sowie der Vielzahl möglicher Technologien, empfiehlt es sich, verschiedene Wege auszuprobieren. Dies
hilft bei der Schaffung einer realistischen Vergleichsbasis zwischen den verschiedenen Technologien und bietet die Möglichkeit,
Ausweichlösungen bei Problemen wie z.B. Performance-Engpässe zu finden oder die tatsächliche Notwendigkeit komplexer 
Technologien zu validieren. Die Entwicklung teilt sich in 2 Hauptphasen:

\begin{enumerate}
    \item \textbf{Basisimplementierung:} In der Basisimplementierung wird ein vollumfänglicher \texttt{SYN}-Scanner implementiert.
    Dies soll zum einen als \textit{Proof of Concept}, und zum anderen als erste Vergleichsgrundlage dienen. Für 
    das Senden, werden bereits die Möglichkeit des Sendens mit \texttt{AF\_PACKET} oder \texttt{AF\_XDP} und jeweils auch in \textit{Batches}\footnote{Gruppen von Paketen}
    oder Einzelpaketen implementiert. Für das Empfangen wird der \textit{Crate}\footnote{Bezeichnung für Bibliothek im Rust-Ökosystem} \texttt{pcap} genutzt,
    welcher das Empfangen von Paketen abstrahiert, allerdings nicht den Netzwerkstack des Linux-Kernels umgeht. 

    Außerdem wird die für die nötige Struktur um die Komponenten zu vernetzen, sowie die Pakete korrekt zu erstellen
    und verarbeiten implementiert, sodass das Programm am Ende einen funktionierenden \texttt{SYN}-Scan vollführen kann.
    Zusätzlich wird auch hier schon auf die möglichst performante Umsetzung der gesamten Struktur, spezifischer
    Umsetzungen und der Wahl von Crates Wert gelegt. 

    \item \textbf{Optimierung des Empfangspfades durch Nutzung von \texttt{eBPF}:} Basierend auf den Messergebnissen der ersten Phase 
    wird die Empfangskomponente hier grundsätzlich verändert, um eine hochperformante, sowie effizienten Paketempfang und
    Paketauswertung zu gewährleisten. Dafür wird ein \texttt{eBPF} in Verbindung mit einem \texttt{RingBuf} zur Protokollierung in Verbindung
    mit einem \texttt{XDP} Programm statt des \texttt{pcap}-Crates genutzt. maybe TODO "bla bla pcap kann ab gewisser Geschwindigkeit nicht mithalten
    oder pcap ist zu ineffizient und/oder rst werden immer automatisch gesendet". Außerdem werden weitere, kleinere
    Performanz-steigernde Maßnahmen addressiert.
\end{enumerate}

\section{Untersuchungsdesign}
Es wird im Folgenden erklärt, wie Performanz im Kontext eines SYN-Scanners zu definieren ist. 
Anschließend werden die in dieser Arbeit zur Evaluation genutzten Metriken erklärt und 
daraufhin die Anforderungen an die Testumgebung vorgestellt und erläutert.  

\subsection{Metriken}
Der Begriff \enquote{Performanz-Effizienz} wird
gemäß der Norm \textbf{ISO/IEC 25010} als die Fähigkeit eines Produkts, seine Funktionen innerhalb festgelegter 
Zeit- und Durchsatz-Parameter zu erfüllen und dabei die Ressourcen unter den gegebenen Bedingungen 
effizient zu nutzen, verstanden \cite{ISO/IEC_25010:2023}. 

Basierend auf der Definition werden folgende Metriken zur Quantifizierung herangezogen, wobei
die Paketrate den Durchsatzparameter und die CPU Auslastung, sowie RAM Verbrauch die Ressourcennutzung 
darstellen:

\begin{itemize}
    \item \textbf{/M-01/\phantomsection\label{req:M-01} Paketrate:} Die Paketrate wird in Pakete pro Sekunde (pps) dargestellt und beschreibt die durchschnittliche Anzahl der erfolgreich an den 
Netzwerkadapter übergebenen Pakete pro Sekunde. Da die Scanner nur sehr kleine Pakete verschicken ist die Paketrate in Performanz-orientierten Projekten dieser
Art der limitierende Faktor \cite{TODO}, weshalb sie stellvertretend(<- anderes wort) als Metrik für die Performanz dient.
    \item \textbf{/M-02/\phantomsection\label{req:M-02} CPU Auslastung:} Die CPU Auslastung von hochperformanten Netzwerkanwendungen findet maßgeblich im Userspace, im Kernelspace und im SoftIRQ statt \cite{TODO}.
deshalb sollte alle drei Bereiche betrachtet werden. Gemessen wird die prozentuale Auslastung der CPU-Kerne.
    \item \textbf{/M-03/\phantomsection\label{req:M-03} RAM Verbauch:} Der RAM-Verbrauch als zweiter primärer Teil der Ressourcenmetriken wird in Megabyte (MB) angegeben und stellt
den Anteil des physisch durch den Scanner belegten Arbeitsspeicher dar. 
\end{itemize}

\subsection{Geplante Testszenarien}
Um die in Abschnitt \ref{Anforderungen} definierten Anforderungen zu validieren, werden drei Testszenarien definiert:

\begin{enumerate}
    \item \textbf{/S-01/ \phantomsection\label{req:S-01} Anforderungsvalidierung (Baseline):} Um die allgemeine Funktionsweise und Stabilität des Scanners zu validieren, soll ein Szenario mit einer künstlich limitierten, aber signifikanten Senderate durchgeführt werden. 
    Ziel ist der Nachweis, dass der Scanner über einen längeren Zeitraum stabil arbeitet und die funktionalen Anforderungen erfüllt. 
    Dies dient auch als Referenzmessung, um sicherzustellen, dass funktionale Anforderungen in späteren Tests nicht explizit getestet werden müssen.
    
    \item \textbf{/S-02/ \phantomsection\label{req:S-02} Ermittlung der Performanzgrenzen:} In diesem Szenario wird jegliche künstliche Drosselung aufgehoben. Das Ziel ist es, die maximalen Durchsatzraten zu ermitteln. 
    Hierbei wird geprüft, wie effizient die Ressourcen unter Volllast genutzt werden, um die nicht funktionalen Anforderungen zu untersuchen.
    
    \item \textbf{/S-03/ \phantomsection\label{req:S-03} Simulation unter realen Parametern und Features:} Um die Vergleichbarkeit zu praxisrelevanten Szenarien zu erhöhen, sollen Parameter gewählt werden, die für echte Internet-Scans 
    typisch sind. Dies soll die Performanz-Effizienz unter möglichst realen Bedingungen testen. Dabei wird auch ein Augenmerk auf die Nutzung von Features gelegt, die im Kontext
    eines realen Scans von Nutzen sind.
\end{enumerate}